#include "memmap.i65"
#include "dma.i65"

menu_init:
	sep #$20 : .as
	rep #$10 : .xl
	lda #^ROOT_DIR
	ldx #!ROOT_DIR
	sta dirptr_bank
	stx dirptr_addr
	sta dirstart_bank
	stx dirstart_addr
	stz menu_state
	stz dirend_onscreen
	lda #$02
	sta cursor_x
	lda #$09
	sta cursor_y
	ldx #$0000
	stx dirptr_idx
	stx menu_sel
	lda #$01
	sta menu_dirty
	rts

menuloop:
menuloop_s1
	sep #$20 : .as
	rep #$10 : .xl
	lda isr_done
	lsr
	bcc menuloop_s1
	stz isr_done
	jsr menu_updates	;update stuff, check keys etc
	lda menu_dirty		;is there ANY reason to redraw the menu?
	cmp #$01
	beq menuloop_redraw 	;then do
	bra menuloop_s1
menuloop_redraw
	stz menu_dirty
	jsr menu_redraw
	jsr menu_cleanup	;update phase 2
	bra menuloop_s1
	rts

menu_cleanup:
	sep #$20 : .as
	rep #$10 : .xl
	lda dirend_onscreen     ;end of file list on screen?
	beq menu_cleanup_out    ;
	lda dirend_idx
	lsr
	lsr
	pha
menu_cleanup_loop               ;pad rest of screen with empty lines
	cmp listdisp            ;end of screen reached?
	beq +                   ;then leave
	pha
	clc
	adc #$09                ;first line in text area
        inc
	sta print_y
        stz print_x
	lda #^space64
	ldx #!space64
	sta print_bank
	stx print_src
	stz print_pal
	lda #64
	sta print_count
	jsr hiprint
	pla
	inc
	bra menu_cleanup_loop
+
	pla
	cmp menu_sel
	beq menu_cleanup_out
	bpl menu_cleanup_out
	sta menu_sel
menu_cleanup_out
	rts
	

menu_updates:
;update selection, scroll etc
	lda menu_sel
	asl
	asl
	sta dirptr_idx
	lda menu_sel
	clc
	adc #$08
	sta bar_yl

;get input
	jsr read_pad
	lda #$04
	and pad1trig+1
	bne key_down
	lda #$08
	and pad1trig+1
	bne key_up
	lda #$01
	and pad1trig+1
	bne key_right
	lda #$02
	and pad1trig+1
	bne key_left
	lda #$80
	and pad1trig+1
	bne key_b
	lda #$20
	and pad1trig+1
	bne key_select
	lda #$80
	and pad1trig
	bne key_a
	bra menuupd_out
key_down
	jsr menu_key_down
	bra menuupd_out
key_up
	jsr menu_key_up
	bra menuupd_out
key_right
	jsr menu_key_right
	bra menuupd_out
key_left
	jsr menu_key_left
	bra menuupd_out
key_b
	jsr menu_key_b
	bra menuupd_out
key_a
	jsr menu_key_a
	bra menuupd_out
key_select
	jsr menu_key_select
	bra menuupd_out

menuupd_out
	lda #$09
	sta cursor_y
	rts


menu_redraw:
	lda menu_state
	beq redraw_filelist
;	cmp 1
;	beq redraw_main
menu_redraw_out
	rts

redraw_filelist
	ldy #$0000
	sty dirptr_idx
	stz dirend_idx
	stz dirend_onscreen
redraw_filelist_loop
	ldy dirptr_idx
	tya
	lsr
	lsr
	cmp listdisp
	beq redraw_filelist_last
	lda dirptr_bank
	phb
	pha
	plb
	rep #$20 : .al
	lda (dirptr_addr), y
	sta @dirent_addr
	iny
	iny
	sep #$20 : .as
	lda (dirptr_addr), y       ; load fileinfo bank
	clc
	adc #$c0                   ; add $C0 for memory map
	sta @dirent_bank           ; store as current bank
	cmp #$c0                   ; if bank was 0 -> dirend entry in DB
	beq redraw_filelist_dirend ; handle dirend
	iny
	lda (dirptr_addr), y
	iny
	sta @dirent_type
	plb
	sty dirptr_idx
	jsr print_direntry
	bra redraw_filelist_loop
redraw_filelist_dirend
	plb
	dey                        ; recover last valid direntry number 
	dey                        ; (we had 2x iny of the direntry pointer above,
	dey                        ;  so account for those too)
	dey
	dey
	dey
	sty dirend_idx             ; dirend_idx <- last valid directory entry.
	lda #$01                   ; encountered during redraw, so must be on screen
	sta dirend_onscreen
	bra redraw_filelist_out
redraw_filelist_last	;check if next offscreen item is end of dir
	lda dirptr_bank
	phb
	pha
	plb
	iny
	iny
	lda (dirptr_addr), y
	beq redraw_filelist_dirend
	plb
redraw_filelist_out
	ldx #$0000
	stx dirptr_idx
	brl menu_redraw_out

print_direntry:
        lda cursor_y
        sta print_y
	inc
        sta cursor_y

	lda dirent_bank
	ldx dirent_addr

	phb
	pha	
	plb	

	lda @dirent_type
	cmp #$80
	rep #$20 : .al
	bne dirent_is_file
dirent_is_dir
	lda #$04	;skip dir tgt
	sta @fd_fnoff
	lda #$01	;different color for dirs
	sta @print_pal
	bra dirent_type_cont
dirent_is_file
	lda #$06	;skip size string
	sta @fd_fnoff
	lda #$00	;palette 0 (white)
	sta @print_pal
dirent_type_cont
	rep #$20 : .al
	txa
	clc
	adc @fd_fnoff
	tax
	sep #$20 : .as
	lda !0, x	;load offset of leaf (file) name
	inc
	rep #$20 : .al
	and #$00ff	;kill hi byte
	sta @fd_fnoff
	txa
	clc
	adc @fd_fnoff
	sta @fd_fnoff
	plb

	lda cursor_x
	sta print_x

	sep #$20 : .as
	ldx fd_fnoff
	lda #54
	sta print_count
	stx print_src
	lda dirent_bank
	sta print_bank
	jsr hiprint

	lda cursor_x
	clc
	adc print_done
	sta print_x

	lda #54
	sec
	sbc print_done
	sta print_count
	lda #^space64
	ldx #!space64
	sta print_bank
	stx print_src
	jsr hiprint

	sep #$20 : .as
	lda dirent_type
	cmp #$80
	bne dirent_is_file_2
	lda #^text_dirmark
	ldx #!text_dirmark
	sta print_bank
	stx print_src
	bra dirent_type_cont_2
dirent_is_file_2
	lda dirent_bank
	ldx dirent_addr
	sta print_bank 
	stx print_src
dirent_type_cont_2
	lda #56
	sta print_x
	lda #6
	sta print_count
	jsr hiprint

	rts
	
menu_key_down:
	lda listdisp
	dec
	cmp menu_sel
	bne +
	lda #$01
	sta menu_dirty
	lda dirend_onscreen
	bne down_out
	rep #$20 : .al
	lda dirptr_addr	
	clc
	adc #$04
	sta dirptr_addr
	sep #$20 : .as
	rts
+	lda dirend_onscreen
	beq +
	lda dirend_idx
	lsr
	lsr
	cmp menu_sel
	beq menuupd_lastcursor
	bcc menuupd_lastcursor
+	lda menu_sel
	inc
	sta menu_sel
down_out
	rts 

menu_key_up:
	lda menu_sel
	bne +
	lda #$01
	sta menu_dirty
	rep #$20 : .al
	lda dirptr_addr
	cmp dirstart_addr
	beq up_out
	sec
	sbc #$04
	sta dirptr_addr
	bra up_out
+	dec
	sta menu_sel
up_out
	sep #$20 : .as
	rts

menuupd_lastcursor
	lda dirend_idx
	lsr
	lsr
	sta menu_sel
	rts

; go back one page
menu_key_left: 
	lda #$01            ; must redraw afterwards
	sta menu_dirty
	rep #$20 : .al
	lda dirptr_addr     ; get current direntry pointer
	beq +               ; special case: if 0, we are at the first entry in memory
	lsr
	lsr                 ; make comparable to listdisp
	cmp listdisp        ; if there's less or equal previous entries...
	beq +               ; ...than display lines, reset to directory start
	bcc +
	sec
	sbc listdisp        ; subtract one screen page's worth of entries
	asl
	asl                 ; make comparable to dirstart_addr again
	cmp dirstart_addr   ; check whether calculated offset is before...
	bcc +               ; ...start of directory
-	sta dirptr_addr     ; store new selected entry
	sep #$20 : .as
	rts
+	lda dirstart_addr   ; reset pointer to start of directory
	stz menu_sel        ; reset the selection cursor too
	bra -

; go forth one page
menu_key_right:
	sep #$20 : .as
	lda dirend_onscreen
	bne menuupd_lastcursor
	lda #$01
	sta menu_dirty
	rep #$20 : .al
	lda listdisp
	asl
	asl
	clc
	adc dirptr_addr
	sta dirptr_addr
	sep #$20 : .as
	rts

menu_key_b:
	jsr select_item
	rts

menu_key_select:
	lda barstep
	beq do_setup448
do_setup224
	jsr setup_224
	rts
do_setup448
	jsr setup_448
	rts

menu_key_a:
	rep #$20 : .al
	lda dirstart_addr
	beq skip_key_a
	sta dirptr_addr
	lda #$0000
	sta menu_sel
	bra select_item
skip_key_a
	sep #$20 : .as
	rts

select_item:
	rep #$20 : .al
	lda menu_sel
	and #$00ff
	asl
	asl
	tay
	sep #$20 : .as
	lda dirptr_bank
	phb
	pha
	plb
	iny
	iny
	iny
	lda (dirptr_addr), y
	beq sel_is_file
	cmp #$80
	beq sel_is_dir
select_item_cont
	plb
	rts
sel_is_file
	jsr select_file
	bra select_item_cont
sel_is_dir
	jsr select_dir
	bra select_item_cont

select_file:
	; have avr load the rom
	dey
	lda (dirptr_addr), y
	sta @AVR_PARAM+2
	rep #$20 : .al
	dey
	dey
	lda (dirptr_addr), y
	sta @AVR_PARAM
	sep #$20 : .as
	lda #$01
	sta @AVR_CMD
	lda #$00
	sta @$4200
	cli
	jsl @wram_fadeloop
	rts

select_dir: ; y = direntry ptr
	dey
	lda (dirptr_addr), y
	clc
	adc #$c0
	sta @dirent_bank
	dey
	dey
	rep #$20 : .al
	lda (dirptr_addr), y
	sta @dirent_addr
	tax
	sep #$20 : .as
	lda @dirent_bank
	phb
	pha
	plb
	lda !2, x ; load linked dir start bank
	clc
	adc #$c0
	sta @dirptr_bank
	sta @dirstart_bank
	rep #$20 : .al
	lda !0, x ; load linked dir start address
	sta @dirptr_addr
	sta @dirstart_addr
	lda #$0000
	sta @menu_sel
	sep #$20 : .as
	lda #$01
	sta @menu_dirty
	plb
	rts


setup_224:
	php
	rep #$30 : .xl : .al
	lda #18
	sta listdisp
	dec
	cmp menu_sel
	bmi setup_224_adjsel
	bra +
setup_224_adjsel
	sta menu_sel
+
	lda #19*64
	sta textdmasize
	lda #$0007
	sta hdma_scroll+8
	sep #$20 : .as
	lda #$07
	sta $2110
	lda #$00
	sta $2110
	lda #$00
	sta barstep
	ora #$08
	sta $2133
	lda #$08
	sta hdma_math_selection
	lda #$01
	sta menu_dirty
	lda #^space64
	ldx #!space64
	sta print_bank
	stx print_src
	stz print_pal
	lda #64
	sta print_count
	lda #27
	sta print_y
	stz print_x
	jsr hiprint
	lda #28
	sta print_y
	jsr hiprint
	jsr hiprint
	
	plp
	rts

setup_448:
	php
	rep #$30 : .xl : .al
	lda #36
	sta listdisp
	lda #38*64
	sta textdmasize
	lda #$ffc6
	sta hdma_scroll+8
	sep #$20 : .as
	lda #$c6
	sta $2110
	lda #$ff
	sta $2110
	lda #$01
	sta barstep
	ora #$08
	sta $2133
	lda #$04
	sta hdma_math_selection
	lda #$01
	sta menu_dirty
	plp
	rts


